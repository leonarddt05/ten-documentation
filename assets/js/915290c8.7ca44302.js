"use strict";(self.webpackChunkobscuro_docs=self.webpackChunkobscuro_docs||[]).push([[1203],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=l(n),h=i,m=p["".concat(s,".").concat(h)]||p[h]||u[h]||r;return n?a.createElement(m,o(o({ref:t},d),{},{components:n})):a.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[p]="string"==typeof e?e:i,o[1]=c;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},815:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:4},o="Developer Quickstart",c={unversionedId:"introduction/developer-quickstart",id:"introduction/developer-quickstart",title:"Developer Quickstart",description:"Obscuro is 100% EVM & uses Solidity, no different than Ethereum or any other L2 on Ethereum. What makes developers achieve this encryption is simple tweaks in the code that we'll show you using a simple data storage example. In Obscuro, the internal node database is encrypted, and the contract execution is also encrypted inside the TEE. Nobody (which includes node operators and the sequencer) can access the internal state of a contract.",source:"@site/docs/introduction/developer-quickstart.md",sourceDirName:"introduction",slug:"/introduction/developer-quickstart",permalink:"/docs/introduction/developer-quickstart",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/introduction/developer-quickstart.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Technology",permalink:"/docs/introduction/technology"},next:{title:"Getting started",permalink:"/docs/category/getting-started"}},s={},l=[{value:"Step 1: Declaring a Public Variable",id:"step-1-declaring-a-public-variable",level:2},{value:"Code:",id:"code",level:3},{value:"Explanation:",id:"explanation",level:3},{value:"Step 2: Transitioning to a Private Variable with a Getter Function",id:"step-2-transitioning-to-a-private-variable-with-a-getter-function",level:2},{value:"Code:",id:"code-1",level:3},{value:"Explanation:",id:"explanation-1",level:3},{value:"Obscuro&#39;s Privacy:",id:"obscuros-privacy",level:3},{value:"Step 4: Implementing Access Control for Enhanced Privacy",id:"step-4-implementing-access-control-for-enhanced-privacy",level:2},{value:"Code:",id:"code-2",level:3},{value:"Explanation:",id:"explanation-2",level:3},{value:"Encrypting ERC20 Tokens:",id:"encrypting-erc20-tokens",level:3},{value:"Step 5: Emitting Events on Data Setting",id:"step-5-emitting-events-on-data-setting",level:2},{value:"Code:",id:"code-3",level:3},{value:"Explanation:",id:"explanation-3",level:3}],d={toc:l},p="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"developer-quickstart"},"Developer Quickstart"),(0,i.kt)("p",null,"Obscuro is 100% EVM & uses Solidity, no different than Ethereum or any other L2 on Ethereum. What makes developers achieve this encryption is simple tweaks in the code that we'll show you using a simple data storage example. In Obscuro, the internal node database is encrypted, and the contract execution is also encrypted inside the TEE. Nobody (which includes node operators and the sequencer) can access the internal state of a contract."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Public state variables in Solidity automatically get a getter function, making them easily accessible.")),(0,i.kt)("h2",{id:"step-1-declaring-a-public-variable"},"Step 1: Declaring a Public Variable"),(0,i.kt)("h3",{id:"code"},"Code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract StorageExample {\n    uint256 public dataPublic;\n}\n")),(0,i.kt)("h3",{id:"explanation"},"Explanation:"),(0,i.kt)("p",null,"In this step, we've declared a public state variable ",(0,i.kt)("inlineCode",{parentName:"p"},"dataPublic"),". Being public, Ethereum automatically generates a getter function for it. On both Ethereum and Obscuro, you can directly access this variable without any restrictions."),(0,i.kt)("h2",{id:"step-2-transitioning-to-a-private-variable-with-a-getter-function"},"Step 2: Transitioning to a Private Variable with a Getter Function"),(0,i.kt)("h3",{id:"code-1"},"Code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 private dataPrivate;\n\nfunction getData() public view returns (uint256) {\n    return dataPrivate;\n}\n")),(0,i.kt)("h3",{id:"explanation-1"},"Explanation:"),(0,i.kt)("p",null,"We've now made our data variable private, meaning it can't be accessed directly from outside the contract. To fetch its value, we've provided a public function ",(0,i.kt)("inlineCode",{parentName:"p"},"getData"),"."),(0,i.kt)("p",null,"On Ethereum and Obscuro, you'd call this function to retrieve the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"dataPrivate"),"."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Private variables in Ethereum can still be accessed directly using the ",(0,i.kt)("inlineCode",{parentName:"p"},"getStorageAt")," method, potentially compromising privacy.")),(0,i.kt)("h3",{id:"obscuros-privacy"},"Obscuro's Privacy:"),(0,i.kt)("p",null,"In Obscuro, the ",(0,i.kt)("inlineCode",{parentName:"p"},"getStorageAt")," method is blocked. This means that there's no way to directly access the values of a private variable outside of its contract. The only way to access such a variable in Obscuro is through a function designed for that purpose."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Obscuro ensures true privacy by blocking direct access methods like ",(0,i.kt)("inlineCode",{parentName:"p"},"getStorageAt"),".")),(0,i.kt)("h2",{id:"step-4-implementing-access-control-for-enhanced-privacy"},"Step 4: Implementing Access Control for Enhanced Privacy"),(0,i.kt)("h3",{id:"code-2"},"Code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'address private authorizedAddress = <Whitelisted_Address>;\n\nfunction getData() public view returns (uint256) {\n    require(msg.sender == authorizedAddress, "Not authorized!");\n    return dataPrivate;\n}\n')),(0,i.kt)("p",null,"Replace ",(0,i.kt)("inlineCode",{parentName:"p"},"<Whitelisted_Address>")," with the desired access address."),(0,i.kt)("h3",{id:"explanation-2"},"Explanation:"),(0,i.kt)("p",null,"To add a layer of privacy, we've restricted the ",(0,i.kt)("inlineCode",{parentName:"p"},"getData")," function to an authorized address. Now, only the specified address can call this function and retrieve the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"dataPrivate"),"."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"On Ethereum, while this does gate the function, remember that the ",(0,i.kt)("inlineCode",{parentName:"p"},"getStorageAt")," method can still be used to bypass this check. On Obscuro, however, this function is the only way to access the private data, making the access control truly effective.")),(0,i.kt)("h3",{id:"encrypting-erc20-tokens"},"Encrypting ERC20 Tokens:"),(0,i.kt)("p",null,"This same technique can be used to encrypt ERC20 tokens. By adding a check in your view functions, you can compare ",(0,i.kt)("inlineCode",{parentName:"p"},"tx.origin")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.sender")," against the accounts allowed to access that data. This ensures that only the token owner can view their balance, adding an extra layer of privacy to your tokens."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Encrypt your ERC20 tokens by adding checks in your view functions, ensuring only the token owner can view their balance.")),(0,i.kt)("h2",{id:"step-5-emitting-events-on-data-setting"},"Step 5: Emitting Events on Data Setting"),(0,i.kt)("h3",{id:"code-3"},"Code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"event DataChanged(uint256 newValue);\n\nfunction setData(uint256 _data) public {\n    dataPrivate = _data;\n    emit DataChanged(_data);\n}\n")),(0,i.kt)("h3",{id:"explanation-3"},"Explanation:"),(0,i.kt)("p",null,"Events in Ethereum are crucial for DApps to react to smart contract state changes. Here, we've added an event ",(0,i.kt)("inlineCode",{parentName:"p"},"DataChanged")," that gets emitted every time the ",(0,i.kt)("inlineCode",{parentName:"p"},"setData")," function is called."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"On Ethereum, once an event is emitted, it's logged on the blockchain. Anyone can access these logs and filter out events based on their signatures. This means that if someone knows about the ",(0,i.kt)("inlineCode",{parentName:"p"},"DataChanged")," event, they can easily track when and what data was set, leading to potential privacy concerns.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Obscuro provides enhanced event privacy, ensuring that only the interacting party can see the relevant events.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," In Obscuro, there are two ways an event can be relevant for an account:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Lifecycle events"),": These are relevant to everyone. A lifecycle event is any event which has no user addresses in its topics."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Account events"),": An event will be relevant for any account in its topics.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This distinction ensures that while some events are broadcasted for all to see (like contract deployments or major state changes), others are kept private, visible only to the parties directly involved.")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Migrate your dApp to Obscuro today and experience enhanced encryption and privacy without compromising on the Ethereum experience."))}u.isMDXComponent=!0}}]);